#include <Atom/Features/RayTracing/RayTracingSrgs.azsli>
#include <Atom/Features/RayTracing/RayTracingMaterialUtils.azsli>
#include <Atom/Features/RayTracing/RayTracingSceneUtils.azsli>
#include "PathTracingCommon.azsli"

#include <Atom/Features/PBR/LightingUtils.azsli>

void ApplyIBL(RayTracingSurfaceData surfaceData, inout float3 diffuseColor)
{
  float sceneIblExposure = pow(2.f, SceneSrg::m_iblExposure);
  float3 irradianceDir = MultiplyVectorQuaternion(surfaceData.m_normal, SceneSrg::m_iblOrientation);
  float3 diffuseSample = SceneSrg::m_diffuseEnvMap.SampleLevel(SceneSrg::m_samplerEnv, GetCubemapCoords(irradianceDir), 0).rgb;
  diffuseColor += diffuseSample * surfaceData.m_albedo * surfaceData.m_diffuseResponse * sceneIblExposure;
}

[shader("closesthit")]
void ClosestHit(inout PayloadData payload, BuiltInTriangleIntersectionAttributes attrib)
{
  RayTracingSceneSrg::MeshInfo meshInfo = RayTracingSceneSrg::m_meshInfo[NonUniformResourceIndex(InstanceIndex())];
  VertexData vertexData = GetHitInterpolatedVertexData(meshInfo, attrib.barycentrics);
  RayTracingMaterialSrg::MaterialInfo materialInfo = RayTracingMaterialSrg::m_materialInfo[NonUniformResourceIndex(InstanceIndex())];
  TextureData textureData = GetHitTextureData(materialInfo, vertexData.m_uv);

  payload.m_hitPosition = mul(ObjectToWorld3x4(), float4(vertexData.m_position, 1.f));
  payload.m_hitNormal = normalize(mul(meshInfo.m_worldInvTranspose, float4(vertexData.m_normal, 0.f)));
  payload.m_hitAlbedo = textureData.m_baseColor.xyz;
  payload.m_hitEmissive = textureData.m_emissiveColor;
}
