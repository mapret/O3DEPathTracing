#include <Atom/Features/RayTracing/RayTracingSrgs.azsli>
#include <Atom/Features/RayTracing/RayTracingMaterialUtils.azsli>
#include <Atom/Features/RayTracing/RayTracingSceneUtils.azsli>
#include "PathTracingCommon.azsli"

#include <Atom/Features/PBR/LightingUtils.azsli>

void ApplyIBL(RayTracingSurfaceData surfaceData, inout float3 diffuseColor)
{
  float sceneIblExposure = pow(2.f, SceneSrg::m_iblExposure);
  float3 irradianceDir = MultiplyVectorQuaternion(surfaceData.m_normal, SceneSrg::m_iblOrientation);
  float3 diffuseSample = SceneSrg::m_diffuseEnvMap.SampleLevel(SceneSrg::m_samplerEnv, GetCubemapCoords(irradianceDir), 0).rgb;
  diffuseColor += diffuseSample * surfaceData.m_albedo * surfaceData.m_diffuseResponse * sceneIblExposure;
}

[shader("closesthit")]
void ClosestHit(inout PayloadData payload, BuiltInTriangleIntersectionAttributes attrib)
{
  RayTracingSceneSrg::MeshInfo meshInfo = RayTracingSceneSrg::m_meshInfo[NonUniformResourceIndex(InstanceIndex())];
  VertexData vertexData = GetHitInterpolatedVertexData(meshInfo, attrib.barycentrics);
  RayTracingMaterialSrg::MaterialInfo materialInfo = RayTracingMaterialSrg::m_materialInfo[NonUniformResourceIndex(InstanceIndex())];
  TextureData textureData = GetHitTextureData(materialInfo, vertexData.m_uv);

  RayTracingSurfaceData surfaceData;
  surfaceData.m_scene = RayTracingSceneSrg::m_scene;
  surfaceData.m_worldPosition = mul(ObjectToWorld3x4(), float4(vertexData.m_position, 1.f));
  surfaceData.m_normal = normalize(mul(meshInfo.m_worldInvTranspose, float4(vertexData.m_normal, 0.f)));
  surfaceData.m_albedo = textureData.m_baseColor.xyz;
  surfaceData.m_diffuseResponse = 1.f;

  if (payload.m_bounces > 1)
  {
    RayDesc ray;
    ray.Origin = surfaceData.m_worldPosition + surfaceData.m_normal * 0.001f;
    ray.Direction = UniformSampleHemisphereDirection(payload.m_rng.GetFloat2(), surfaceData.m_normal);
    ray.TMin = 0.f;
    ray.TMax = RayTracingGlobalSrg::m_maxRayLength;

    PayloadData payload2 = (PayloadData)0;
    payload2.m_bounces = payload.m_bounces - 1;
    payload2.m_rng = payload.m_rng;
    TraceRay(RayTracingSceneSrg::m_scene, RAY_FLAG_NONE, 0xFF, 0, 1, 0, ray, payload2);

    if (!payload2.m_wasMiss)
    {
      payload.m_color =
        DiffuseLambertian(surfaceData.m_albedo, surfaceData.m_normal, ray.Direction, surfaceData.m_diffuseResponse) *
        payload2.m_color;
      return;
    }
  }

  float3 diffuseColor = float3(0.f, 0.f, 0.f);
  for (int index = 0; index < RayTracingSceneSrg::m_directionalLightCount; index++)
  {
    ApplyDirectionalLight(RayTracingSceneSrg::m_directionalLights[index], surfaceData, diffuseColor);
  }
  payload.m_color = diffuseColor;
}
