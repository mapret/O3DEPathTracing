#include <Atom/Features/RayTracing/RayTracingSrgs.azsli>
#include "PathTracingCommon.azsli"

// Since all ray tracing shaders need to include the exact same SRGs (see comment in RayTracingSrgs.azsli), no
// additional SRGs or SRG members can be added. Therefore, some existing members of RayTracingGlobalSrg are reused for
// path tracing
#define AccumulationImage RayTracingGlobalSrg::m_fallbackAlbedo
#define OutputImage       RayTracingGlobalSrg::m_fallbackColor
#define ConfigBufferIndex RayTracingGlobalSrg::m_reflectionMethod

struct PathTracingConfig
{
  uint m_frameCount;
  uint m_clearRequest;
};

[shader("raygeneration")] void RayGeneration()
{
  uint2 pixelCoords = DispatchRaysIndex().xy;
  uint2 dimensions = DispatchRaysDimensions().xy;
  float2 coordsNDC = ((float2)pixelCoords / dimensions * 2.f - 1.f) * float2(1.f, -1.f);

  float4 rayTarget = mul(ViewSrg::m_viewProjectionInverseMatrix, float4(coordsNDC, 1.f, 1.f));
  float3 rayDir = normalize(rayTarget.xyz / rayTarget.w - ViewSrg::m_worldPosition);

  RayDesc ray;
  ray.Origin = ViewSrg::m_worldPosition;
  ray.Direction = rayDir;
  ray.TMin = 0.f;
  ray.TMax = RayTracingGlobalSrg::m_maxRayLength;

  PathTracingConfig config = Bindless::GetRWByteAddressBuffer(ConfigBufferIndex).Load<PathTracingConfig>(0);
  if (config.m_clearRequest)
  {
    AccumulationImage[pixelCoords] = float4(0.f, 0.f, 0.f, 0.f);
  }

  float3 colorSum = float3(0.f, 0.f, 0.f);
  uint sampleCount = 1;
  for (uint i = 0; i < sampleCount; i++)
  {
    PayloadData payload = (PayloadData)0;
    payload.m_bounces = 3;
    payload.m_rng.Init(pixelCoords.x, pixelCoords.y, config.m_frameCount, i);
    TraceRay(RayTracingSceneSrg::m_scene, RAY_FLAG_NONE, 0xFF, 0, 1, 0, ray, payload);
    colorSum += payload.m_color;
  }

  AccumulationImage[pixelCoords] += float4(colorSum / sampleCount, 1.f);
  OutputImage[pixelCoords] = float4(AccumulationImage[pixelCoords].xyz / AccumulationImage[pixelCoords].w, 1.f);
}
