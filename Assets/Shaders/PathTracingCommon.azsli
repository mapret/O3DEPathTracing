#pragma once

#include "Random.azsli"
#include <Atom/RPI/Math.azsli>

struct PayloadData
{
  bool m_wasMiss;
  float3 m_hitPosition;
  float3 m_hitNormal;
  float3 m_hitAlbedo;
  float3 m_hitEmissive;
};

struct RayTracingSurfaceData
{
  RaytracingAccelerationStructure m_scene;
  float3 m_worldPosition;
  float3 m_normal;
  float3 m_albedo;
  float3 m_diffuseResponse;
};

float3 SphericalDirection(float sinTheta, float cosTheta, float phi)
{
  return float3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);
}

float3 UniformSampleHemisphereUnit(float2 xi)
{
  float r = sqrt(max(0.f, 1.f - xi.x * xi.x));
  float phi = TWO_PI * xi.y;
  return SphericalDirection(r, xi.x, phi);
}

float3 ImportanceSampleBeckmannUnit(float2 xi)
{
  float alpha = 1.f;

  float logSample = log(1 - xi.x);
  if (isinf(logSample))
    logSample = 0;
  float tan2theta = -alpha * alpha * logSample;
  float phi = xi.y * TWO_PI;

  float cosTheta = 1.f / sqrt(1 + tan2theta);
  float sinTheta = sqrt(max(0.f, 1.f - cosTheta * cosTheta));

  return SphericalDirection(sinTheta, cosTheta, phi);
}

float3 TransformVectorToWorldSpace(float3 normalWS, float3 direction)
{
  float3 upVector = abs(normalWS.z) < 0.999f ? float3(0.f, 0.f, 1.f) : float3(1.f, 0.f, 0.f);
  float3 tangentWS = normalize(cross(upVector, normalWS));
  float3 bitangentWS = cross(normalWS, tangentWS);
  return tangentWS * direction.x + bitangentWS * direction.y + normalWS * direction.z;
}

float3 UniformSampleHemisphere(float2 xi, float3 normalWS)
{
  float3 dir = UniformSampleHemisphereUnit(xi);
  return TransformVectorToWorldSpace(normalWS, dir);
}

float3 ImportanceSampleBeckmann(float2 xi, float3 normalWS)
{
  float3 dir = ImportanceSampleBeckmannUnit(xi);
  return TransformVectorToWorldSpace(normalWS, dir);
}

float3 DiffuseLambertian(float3 albedo, float3 normal, float3 dirToLight, float3 diffuseResponse)
{
  float NdotL = saturate(dot(normal, dirToLight));
  return albedo * NdotL * diffuseResponse;
}

void ApplyDirectionalLight(RayTracingSceneSrg::DirectionalLight light,
                           RayTracingSurfaceData surfaceData,
                           inout float3 diffuseColor)
{
  RayDesc lightRay;
  lightRay.Origin = surfaceData.m_worldPosition + surfaceData.m_normal * 0.001f;
  lightRay.Direction = normalize(-light.m_direction);
  lightRay.TMin = 0.f;
  lightRay.TMax = 1e20f;
  PayloadData lightRayPayload = (PayloadData)0;
  TraceRay(surfaceData.m_scene,
           RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER,
           0xFF,
           0,
           1,
           0,
           lightRay,
           lightRayPayload);

  if (lightRayPayload.m_wasMiss)
  {
    diffuseColor +=
      DiffuseLambertian(
        surfaceData.m_albedo, surfaceData.m_normal, normalize(-light.m_direction), surfaceData.m_diffuseResponse) *
      light.m_rgbIntensity;
  }
}
