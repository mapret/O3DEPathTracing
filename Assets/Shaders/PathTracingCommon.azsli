#pragma once

#include "Random.azsli"
#include <Atom/Features/PBR/Microfacet/Brdf.azsli>

struct PayloadData
{
  Xorshift64 m_rng;
  float3 m_color;
  int m_bounces;
  bool m_wasMiss;
};

struct RayTracingSurfaceData
{
  RaytracingAccelerationStructure m_scene;
  float3 m_worldPosition;
  float3 m_normal;
  float3 m_albedo;
  float m_diffuseResponse;
};

float3 UniformSampleHemisphere(float2 xi)
{
  float r = sqrt(max(0.f, 1.f - xi.x * xi.x));
  float phi = TWO_PI * xi.y;
  return float3(r * cos(phi), r * sin(phi), xi.x);
}

float3 UniformSampleHemisphereDirection(float2 xi, float3 normalWS)
{
  float3 dir = UniformSampleHemisphere(xi);
  float3 upVector = abs(normalWS.z) < 0.999f ? float3(0.f, 0.f, 1.f) : float3(1.f, 0.f, 0.f);
  float3 tangentWS = normalize(cross(upVector, normalWS));
  float3 bitangentWS = cross(normalWS, tangentWS);
  return tangentWS * dir.x + bitangentWS * dir.y + normalWS * dir.z;
}

void ApplyDirectionalLight(RayTracingSceneSrg::DirectionalLight light,
                           RayTracingSurfaceData surfaceData,
                           inout float3 diffuseColor)
{
  RayDesc lightRay;
  lightRay.Origin = surfaceData.m_worldPosition + surfaceData.m_normal * 0.001f;
  lightRay.Direction = normalize(-light.m_direction);
  lightRay.TMin = 0.f;
  lightRay.TMax = 1e20f;
  PayloadData lightRayPayload = (PayloadData)0;
  TraceRay(surfaceData.m_scene,
           RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER,
           0xFF,
           0,
           1,
           0,
           lightRay,
           lightRayPayload);

  if (lightRayPayload.m_wasMiss)
  {
    diffuseColor +=
      DiffuseLambertian(
        surfaceData.m_albedo, surfaceData.m_normal, normalize(-light.m_direction), surfaceData.m_diffuseResponse) *
      light.m_rgbIntensity;
  }
}
